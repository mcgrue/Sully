///
/// Grue's dumb and probably extraneous render engine, mark 3!
///
/// "The McGrender Engine!"
///
/// Stupider and simpler than it's older brothers!!!
///
///
/// Cons:
/// * doesn't take care of sorting issues
/// * doesn't handle overflows kindly
/// * leaves a lot up to the programmer for custom things
/// * doesn't nativly support frame-animations
///
/// Pros:
/// * handles movement of sprites while persistantly drawing them
/// * ...
/// * man I need to recode this.


///
/// one at the tail for temp!
///
#define MCGRENDER_MAX 			127
#define MCG_TEMP 			127
#define MCGRENDER_STACKSIZE 		128

/// fixed point MADNESS!
#define MC_MULTIPLIER 1000

///
struct mcg_image_mkIII 
{
	int image;
	int x,y;
	int start_x, start_y;
	int final_x, final_y;
	int is_moving, is_on, is_callfunc;
	int x_chunk, y_chunk;
	int last_time;
	int delay;
	string callfunc, delete_callfunc;
	
	int delete_on_stop;
}

mcg_image_mkIII mcg_eng[MCGRENDER_STACKSIZE];
int mcg_pos = 0;

/// destroys everything on this mcgrender
void mcg_destroy() 
{
	int i;
	
	for( i=0; i<MCGRENDER_STACKSIZE; i++ ) 
	{
		CallFunction( mcg_eng[i].delete_callfunc );
		mcg_delete( i );
		mcg_eng[i].is_on = 0;
	}
	
	mcg_pos = 0;
}

/// copies a mcg_eng entry from index 'pimp' into entry 'bitch'.
void mcg_copy( int bitch, int pimp ) 
{
	mcg_eng[bitch].image 		= mcg_eng[pimp].image;
	mcg_eng[bitch].x 		= mcg_eng[pimp].x;
	mcg_eng[bitch].y 		= mcg_eng[pimp].y;
	mcg_eng[bitch].start_x 		= mcg_eng[pimp].start_x;
	mcg_eng[bitch].start_y 		= mcg_eng[pimp].start_y;
	mcg_eng[bitch].final_x 		= mcg_eng[pimp].final_x;
	mcg_eng[bitch].final_y 		= mcg_eng[pimp].final_y;
	mcg_eng[bitch].is_moving	= mcg_eng[pimp].is_moving;
	mcg_eng[bitch].is_on 		= mcg_eng[pimp].is_on;
	mcg_eng[bitch].is_callfunc	= mcg_eng[pimp].is_callfunc;
	mcg_eng[bitch].x_chunk 		= mcg_eng[pimp].x_chunk;
	mcg_eng[bitch].y_chunk 		= mcg_eng[pimp].y_chunk;
	mcg_eng[bitch].last_time 	= mcg_eng[pimp].last_time;
	mcg_eng[bitch].callfunc 	= mcg_eng[pimp].callfunc;
	mcg_eng[bitch].delete_on_stop 	= mcg_eng[pimp].delete_on_stop;	
	mcg_eng[bitch].delete_callfunc 	= mcg_eng[pimp].delete_callfunc;	
}

/// switches the contents of mcg_eng[a] and mcg_eng[b]
void mcg_switch( int a, int b ) 
{
	mcg_copy( MCG_TEMP , a );
	mcg_copy( a, b );
	mcg_copy( b, MCG_TEMP );
}

/// Calls the specified mcg_eng entry's delete function, and erases it's image from memory.
///
/// Note, deleting from the stack will likely corrupt any index references.
/// Delete with caution! :)
void mcg_delete( int idx ) 
{
	int i;
	CallFunction( mcg_eng[idx].delete_callfunc );
	
	if( mcg_eng[idx].image )
	{
		FreeImage( mcg_eng[idx].image );
	}
	
	if( idx < mcg_pos ) 
	{
		
		//
		// Collapse everything down a slot
		for( i=idx; i<mcg_pos-1; i++ ) 
		{
			mcg_copy( i, i+1 );
		}
		
		mcg_pos--; //and decrement the end-of-stack cursor
	}
}

/// Adds a simple image to the renderstack.
/// @param start_x the starting x coordinate for this image.
/// @param start_y the starting y coordinate for this image.
/// @param end_x the ending x coordinate for this image.
/// @param end_y the ending y coordinate for this image.
/// @param delay how many hundreds of a second this image should take in getting from (start_x, start_y) to (end_x, end_y)
/// @param image the image reference to do all of this magically moving blitting.
int mcg_add( int start_x, int start_y, int end_x, int end_y, int delay, int image ) 
{
	int i;
	
	//
	// Basic error checking.
	//
	if( mcg_pos >= MCGRENDER_MAX ) {
		FATAL_ERROR( "mcg_add: tried to add too many images, old bean." );
		return 0-1;
	}

	// The image reference
	mcg_eng[mcg_pos].image = image;
	
	mcg_eng[mcg_pos].delay = delay;
	

	// Set up the coordinates
	mcg_eng[mcg_pos].x = start_x * MC_MULTIPLIER;
	mcg_eng[mcg_pos].y = start_y * MC_MULTIPLIER;
	
	mcg_eng[mcg_pos].start_x = mcg_eng[mcg_pos].x;
	mcg_eng[mcg_pos].start_y = mcg_eng[mcg_pos].y;

	mcg_eng[mcg_pos].final_x = end_x * MC_MULTIPLIER;
	mcg_eng[mcg_pos].final_y = end_y * MC_MULTIPLIER;

	mcg_eng[mcg_pos].is_callfunc = 0;
	mcg_eng[mcg_pos].callfunc = "";
	
	mcg_eng[mcg_pos].delete_on_stop = 0;
	

	// calculate the chunks.
	mcg_calc_chunk( mcg_pos, delay );
	

	// init the time
	mcg_eng[mcg_pos].last_time = systemtime;
	

	//and we're spent!
	i = mcg_pos;
	mcg_pos++;
	return i;
}


/// Reverses direction of the image's motion without altering the chunk's scalar value or the current position.
///
/// @param idx the index of the mcg_eng entry to reverse the direction of motion of.
void mcg_reverse( int idx ) 
{
	int temp_x, temp_y;
	
	//reverse the chunks
	mcg_eng[idx].x_chunk = 0 - mcg_eng[idx].x_chunk;
	mcg_eng[idx].y_chunk = 0 - mcg_eng[idx].y_chunk;
	
	temp_x = mcg_eng[idx].final_x;
	temp_y = mcg_eng[idx].final_y;
	
	mcg_eng[idx].final_x = mcg_eng[idx].start_x;
	mcg_eng[idx].final_y = mcg_eng[idx].start_y;

	mcg_eng[idx].start_x = temp_x;
	mcg_eng[idx].start_y = temp_y;
	
	if( !mcg_eng[idx].x_chunk && !mcg_eng[idx].y_chunk ) {
		mcg_calc_chunk( idx, mcg_eng[idx].delay );
	}
	
	mcg_eng[idx].is_moving = 1;
}



/// Helper function.  Recalculates chunks.  
/// If there's a new directional vector, sets the object to on and moving.  
void mcg_calc_chunk( int idx, int delay ) {
	mcg_eng[idx].x_chunk = (mcg_eng[idx].final_x-mcg_eng[idx].x) / delay;
	mcg_eng[idx].y_chunk = (mcg_eng[idx].final_y-mcg_eng[idx].y) / delay;	
	
	if( mcg_eng[idx].x_chunk || mcg_eng[idx].y_chunk ) 
	{
		mcg_eng[idx].is_on = 1;
		mcg_eng[idx].is_moving = 1;
	}
}

/// Add an image to the render engine in "complex" mode.  Which means it calls the sepcified callfunc instead of mcg_draw when it's turn comes up to be drawn.
///
/// @param callfunc the custom 
int mcg_add_complex( string callfunc, int image ) 
{
	int i;
	if( mcg_pos >= MCGRENDER_MAX ) {
		FATAL_ERROR( "mcg_add_complex: tried to add too many images. BAD CODER NO COFFEW." );
		return 0-1;
	}
	
	mcg_eng[mcg_pos].image			= image;
	mcg_eng[mcg_pos].last_time		= systemtime;
	mcg_eng[mcg_pos].callfunc		= callfunc;

	mcg_eng[mcg_pos].is_moving		= 1;
	mcg_eng[mcg_pos].is_on			= 1;
	mcg_eng[mcg_pos].is_callfunc	= 1;


	//
	// Turn these off.  The callfunc may use them, but it's up to the user to override them.
	//
	mcg_eng[mcg_pos].x = 0;
	mcg_eng[mcg_pos].y = 0;
	mcg_eng[mcg_pos].start_x = 0;
	mcg_eng[mcg_pos].start_y = 0;
	mcg_eng[mcg_pos].final_x = 0;
	mcg_eng[mcg_pos].final_y = 0;
	mcg_eng[mcg_pos].x_chunk = 0;
	mcg_eng[mcg_pos].y_chunk = 0;
	
	i = mcg_pos;
	mcg_pos++;
	return i;
}

void mcg_set_x(int idx, int n ) { mcg_eng[idx].x = (n * MC_MULTIPLIER); }
void mcg_set_y(int idx, int n ) { mcg_eng[idx].y = (n * MC_MULTIPLIER); }

void mcg_set_final_x(int idx, int n ) { mcg_eng[idx].final_x = (n * MC_MULTIPLIER); }
void mcg_set_final_y(int idx, int n ) { mcg_eng[idx].final_y = (n * MC_MULTIPLIER); }


int mcg_get_x(int idx ) { return mcg_eng[idx].x / MC_MULTIPLIER; }
int mcg_get_y(int idx ) { return mcg_eng[idx].y / MC_MULTIPLIER; }


//
// encapsulates the drawing mechanisms of a non-callfunc image
//
int mcg_ticks;
void mcg_draw( int idx ) {
	if( !mcg_eng[idx].is_moving ) { //it's not moving...
		TBlit( (mcg_eng[idx].x/MC_MULTIPLIER), (mcg_eng[idx].y/MC_MULTIPLIER), mcg_eng[idx].image, screen );
//log( "  sitll "+str(mcg_eng[idx].image)+" at ("+str((mcg_eng[idx].x/MC_MULTIPLIER))+","+str((mcg_eng[idx].y/MC_MULTIPLIER))+")" );
		mcg_eng[idx].last_time = systemtime;
	} else { //it's moving!
		
		mcg_ticks = systemtime - mcg_eng[idx].last_time;
		
		mcg_eng[idx].x += (mcg_ticks * mcg_eng[idx].x_chunk);
		mcg_eng[idx].y += (mcg_ticks * mcg_eng[idx].y_chunk);
		
		mcg_eng[idx].last_time = systemtime;
		
		mcg_moving_helper(idx);
		
		TBlit( (mcg_eng[idx].x/MC_MULTIPLIER), (mcg_eng[idx].y/MC_MULTIPLIER), mcg_eng[idx].image, screen );
//log( "moving "+str(mcg_eng[idx].image)+" at ("+str((mcg_eng[idx].x/MC_MULTIPLIER))+","+str((mcg_eng[idx].y/MC_MULTIPLIER))+")" );	
		if( !mcg_moveCheck(idx) ) {
			mcg_eng[idx].is_moving = 0;
		}
	}
}


/// Helper function.  checks for overspill.  
/// Not really sure what it does at this moment.  
/// But whatever it does, it does it.
///
/// @param idx the mcg_eng index to do this mysterious check to.
/// @author mcgrue (befuddled)
void mcg_moving_helper( int idx ) 
{
	//true if moving in x;
	if( mcg_eng[idx].x_chunk ) 
	{
		//moving forward
		if( mcg_eng[idx].x_chunk > 0 ) 
		{ 
			if( mcg_eng[idx].x > mcg_eng[idx].final_x ) 
			{
				mcg_eng[idx].x = mcg_eng[idx].final_x;
				mcg_eng[idx].x_chunk = 0;
			} 
		} 
		
		//moving backwards
		else 
		{ 
			if( mcg_eng[idx].x < mcg_eng[idx].final_x ) 
			{
				mcg_eng[idx].x = mcg_eng[idx].final_x;
				mcg_eng[idx].x_chunk = 0;
			} 
		}
		
	} //done with x-moving block


	//true if moving in y;
	if( mcg_eng[idx].y_chunk ) 
	{ 
		//moving forward
		if( mcg_eng[idx].y_chunk > 0 ) 
		{ 
			if( mcg_eng[idx].y > mcg_eng[idx].final_y ) 
			{
				mcg_eng[idx].y = mcg_eng[idx].final_y;
				mcg_eng[idx].y_chunk = 0;
			} 

		} 
		
		//moving backwards
		else 
		{ 
			if( mcg_eng[idx].y < mcg_eng[idx].final_y ) 
			{
				mcg_eng[idx].y = mcg_eng[idx].final_y;
				mcg_eng[idx].y_chunk = 0;
			} 
		}
		
	} //done with y-moving block
}

/// Helper function.  Checks to see if a moving image should be set to unmoving.
/// Called in mcg_draw();
/// @param idx the mcg_eng index to check.
/// @see mcg_draw()
int mcg_moveCheck( int idx ) {
	
	if( mcg_eng[idx].x != mcg_eng[idx].final_x || mcg_eng[idx].y != mcg_eng[idx].final_y ) 
	{
		return 1;
	} 
	else 
	{
		return 0;
	}
}

void mcgrender() {
	
	int i;
	
	for( i=0; i<mcg_pos; i++ ) {
		if( mcg_eng[i].is_on ) {
			if( mcg_eng[i].is_callfunc ) {
				callfunction( mcg_eng[i].callfunc );
			} else {
				mcg_draw(i);
			}
		}
		
//		if( !mcg_eng[i].is_callfunc )
//			PrintString(mcg_eng[i].x/MC_MULTIPLIER,mcg_eng[i].y/MC_MULTIPLIER, screen, textfont, "#"+str(i)+": "+str(mcg_eng[i].delete_on_stop));
		
//		if( !mcg_eng[i].is_callfunc )
//			PrintString(10, 10+(i*10), screen, textfont, "#"+str(i)+": ("+str((mcg_eng[i].x)/MC_MULTIPLIER)+		 ","+str((mcg_eng[i].y)/MC_MULTIPLIER)+") ("+str(ImageWidth(mcg_eng[i].image))+","+str(ImageHeight(mcg_eng[i].image))+")"  );

		if( mcg_eng[i].delete_on_stop ) {
			if( mcg_eng[i].is_moving == 0 ) {
				mcg_delete(i);
				i--;
			}
		}
	}	
}

/// Debug function.  Logs out all of the vitals for mcg_eng[idx].
/// @param idx the mcg_eng[] entry to print out to the log.
void mcg_print( int idx ) 
{
	log( "mcg_eng["+str(idx)+"]" );
	log( "======================" );

	log( "          image; " + str(mcg_eng[idx].image) );
	log( "            x,y: " + str(mcg_eng[idx].x) + "," + str(mcg_eng[idx].y) 				+ " ("+str((mcg_eng[idx].x)/MC_MULTIPLIER)+		 ","+str((mcg_eng[idx].y)/MC_MULTIPLIER)+")" );
	log( "final_x,final_y: " + str(mcg_eng[idx].final_x) + "," + str(mcg_eng[idx].final_y) 	+ " ("+str((mcg_eng[idx].final_x)/MC_MULTIPLIER)+","+str((mcg_eng[idx].final_y)/MC_MULTIPLIER)+")" );
	log( "start_x,start_y: " + str(mcg_eng[idx].start_x) + "," + str(mcg_eng[idx].start_y) 	+ " ("+str((mcg_eng[idx].start_x)/MC_MULTIPLIER)+","+str((mcg_eng[idx].start_y)/MC_MULTIPLIER)+")" );
	log( "x_chunk,y_chunk: " + str(mcg_eng[idx].x_chunk) + "," + str(mcg_eng[idx].y_chunk) 	+ " ("+str((mcg_eng[idx].x_chunk)/MC_MULTIPLIER)+","+str((mcg_eng[idx].y_chunk)/MC_MULTIPLIER)+")" );
	log( "" );
	log( "      is_moving: " + str(mcg_eng[idx].is_moving) );
	log( "          is_on: " + str(mcg_eng[idx].is_on) );
	log( "    is_callfunc: " + str(mcg_eng[idx].is_callfunc) );
	log( "" );
	log( "      last_time; " + str(mcg_eng[idx].last_time) );
	log( "       callfunc: " + mcg_eng[idx].callfunc );
	log("");
	log("");
}

/// Logs out all mcg_eng entries that are presently 'on'
void mcg_print_all() 
{
	int i;
	for( i=0; i<mcg_pos; i++ ) {
		if( mcg_eng[i].is_on ) {
			mcg_print( i );
		}
	}
}