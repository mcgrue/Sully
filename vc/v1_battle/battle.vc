/// battle-log!
///
void bLog( String s )
{
    Log( s );
}
/// defines the maximim number of enemies in a battle
#define BATTLE_MAX_ENEMIES  16

#define BASE_HIT    80
#define BASE_DELAY  100
#define MAX_DELAY   300

#define MAX_DAMAGE  9999

#define ATTACK_MISS 0
#define ATTACK_HIT  1
#define ATTACK_CRIT 2



/// the iconfile index for a weaponless (bare hands) attack.
#define ICON_NO_WEAPON  0

/// What percentage of their default share of EXP dead party members get. This works a little differently
/// depending on whether EXP is divided or assigned equally to everyone: see the EXP policies below.
#define DEAD_EXP_SHARE 100 // Being dead is no reason to discriminate against someone!

/// Set to a number that determines the policy for assigning combat EXP. 
/// >> POLICY 0: The summed EXP is given to every living character, with dead characters getting DEAD_EXP_SHARE% of that amount.
/// >> POLICY 1: The summed EXP is divided equally among all characters, rounding down. If DEAD_EXP_SHARE is 0, dead characters are excluded. If it's any nonzero value, they get their full share.
#define EXP_POLICY 0

#define EXP_POLICY_TOTAL 0
#define EXP_POLICY_DIVIDE 1

/// Set to a number that determines the elemental overlap policy. This is what happens when a character has multiple equipment effects (either innate or worn) that modify the same elemental damage. There are three policies:
/// >> POLICY 0: The best elemental modifier (the one that provides the least damage or most HP gain) prevails.
/// >> POLICY 1: The worst elemental modifier (the one that provides the most damage or least HP gain) prevails.
/// >> POLICY 2: The elemental modifiers stack numerically. 
#define ELEMENTAL_OVERLAP_POLICY 2

#define ELEMENTAL_POLICY_BEST   0
#define ELEMENTAL_POLICY_WORST  1
#define ELEMENTAL_POLICY_STACK  2

/// if this is defined as a number greater than one, it caps the maximum 
/// the elemental-stack policy can have for a numerator or denominator value.  For instance,
/// setting it to 3 will make the most damage a stack can make 3 times the base, and the least 
/// 1/3rd the base.  Isn't that fun?
#define ELEMENTAL_POLICY_STACK_MAX  0

/// if this is true, the system will report an error if the battle group's callfunction is requested
/// in it's definition entry but the specified callfunc does not exist.
#define BATTLE_GROUP_CALLFUNC_STRICT 0

/// the battle action queue
#include "vc/v1_battle/battle_queue.vc"

/// the battle action queue
#include "vc/v1_battle/battle_enemy.vc"

/// the battle action queue
#include "vc/v1_battle/battle_stats.vc"

/// the battle targetting functions
#include "vc/v1_battle/battle_targetting.vc"

/// functions pertaining to graphical effects
#include "vc/v1_battle/battle_effect.vc"

/// the funky bouncy-number-queueing, actual-damage-resolution library.
#include "vc/v1_battle/GATTACA.vc"

/// the main battle loop!
#include "vc/v1_battle/battle_start.vc"

// the battle message queue, for skill names and "Justice is not the only right in this world" and stuff.
#include "vc/v1_battle/battle_message.vc"

/// flag denoting if we're presently in a battle or not.
int __sully_battle_flag;

/// an array of sprite references for the enemy sprites.
int bs_enemy_sprite_ref[BATTLE_MAX_ENEMIES];

///The number of presently active enemy sprites in this battle.
int bs_enemy_sprite_ref_count;

/// an array of sprite references for the ally sprites.
int bs_ally_sprite_ref[MAX_PARTY_SIZE];

/// just a container for cleanup purposes...
int previous_battle_allycount;

// this is to return 1 when we're in a battle, 0 when we're not!
int IsInBattle() 
{
    return __sully_battle_flag;
}

int imBattleBG;

int imBattleActorPointer;

int fontBattleWhite, fontBattleGreen, fontBattleRed, fontBattleGrey;

int ref_BattleHUD, ref_BattleQueue, ref_bouncynums, ref_slashy, ref_battlemenu, ref_battletarg, ref_battlemessage;

int ref_effects;

/// the image layer reference for the "this PC is presently acting" thing.
int ref_actorindicator;

int bs_layerBG, bs_layerFG, bs_layerInterface;


/// the handle for the debug window!
int h_window_debug;

/// 0 if no debug, 1 if yes debug!
int mode_battle_debug = 1;
int _debug_tick_counter = 0; //counts how many ticks have occurred this battle
int debug_metamode_active = 0; //1 if we want to be 'normal' while in debug mode, 0 if we want to be in the awesome 'step' mode.
int debug_metamode_active_steppassthru = 0; /// the trap for the stepping.

/// the formatted string for the ally's inventory.  
/// Kept here so it only needs to be regenerated when necessary, and otherwise pulled out of
/// this variable.
///string __battle_inventory;


int ____battle_over_maaaan = 0;

/// stuff to do at the very end of a battle.
void endOfBattle()
{
    int i;
    for( i=0; i<PartySize(); i++ )
    {
        trigger_on_end( party[i] );
        WipeAllyBattleModifiers( party[i] );
    }
    
    DestroyBattleMessage();
    TurnBattleEffectOff(0);
       
    if( mode_battle_debug )
    {
        WindowClose( h_window_debug );
        mcg_turn_off( ref_BattleQueue );
    }
    
    V1_StartMusic( __music_before_battle );
}

void TurnOffTheBattle() {
    ____battle_over_maaaan = 1;
}

int IsTheBattleOver() {
    return ____battle_over_maaaan;
}

/// stuff to cleanup before starting a new battle.
void cleanupPreviousBattle()
{
    int i;

_debug_tick_counter = 0;

    /// clean out the mcgrender engine.  Hope you saved anything you needed in there 
    /// from before!
    mcg_destroy();

    /// clean out the previous battle background to make way for the new one.
    if( ImageValid(imBattleBG) )
    {
        FreeImage( imBattleBG );
    }
    
    if( ImageValid(imBattleActorPointer) )
    {
        FreeImage( imBattleActorPointer );
    }
    
    ///wipe out the previous enemy sprites...
    for( i=0; i<bs_enemy_sprite_ref_count; i++ )
    {
        FreeSprite( bs_enemy_sprite_ref[i], 1 );
    }
    
    ///wipe out the previous ally sprites
    ///wipe out the previous enemy sprites...
    for( i=0; i<previous_battle_allycount; i++ )
    {
        FreeSprite( bs_ally_sprite_ref[i], 1 );
    }
    
    /// wipe out the old enemy party associations.
    resetBattleEnemyList();
    
    /// wipe out the old battle queue.
    clear_battle_queue();
    
    /// turns the battle menu off.  Duh.
    TurnBattleMenuOff();
    
    /// initialize the battle inventory.
    GenerateBattleMenuInventory( 1 );
    
    /// make sure the engine knows that there isn't a graphical 
    /// battle effect resolving.  The '0' in there means to not trigger 
    /// the GATTACA library.
    TurnBattleEffectOff( 0 );
    
    /// Make sure GATTACA is clear.  GATTACA is a little library that resolves 
    /// the actual healing/hurting of MP/HP, triggers bouncy numbers, animates 
    /// weapon slashies, and all that stuff that generally  happens at the end 
    /// of a battle action.
    EmptyGATTACA();
    
    ///turn the slashy library off!
    TurnSlashyOff();
        
    /// zero out the battle effect delay variable.
    __after_effect_targtime = 0;
    
    /// zero out the rewards switch.
    __initRewards = 0;

    /// battle can't be over if it's just startin'.  Woo!    
    ____battle_over_maaaan = 0;
    
    Unpress(0);
}


/// puts the party in their place.  
/// Just one of many things that could be recoded nicer.
void BsPlacePartySprites()
{
    int pos1 = 50;
    int pos2 = 87;
    int pos3 = 124;
    int pos4 = 161;
    int pos5 = 198;
    
    int base_x = 256;
    int min_x = 8;
    int max_x = 22;
    
    int i, x, ref;
    
    /// store this battle's partysize so we can clean it nicely before next batlle,
    /// in case of a change in the roster.
    previous_battle_allycount = PartySize();

    for( i=0; i<PartySize(); i++ )
    {
        bs_ally_sprite_ref[i] = LoadSprite( 
            master_cast[party[i]].battle_sprite, SPRITETYPE_ALLY 
        );
        
        setStartingBattleSpriteAnimations( party[i], bs_ally_sprite_ref[i] );    
    }
    
    switch( PartySize() )
    {
        case 1:
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos3,   x,pos3, 0, bs_ally_sprite_ref[0] );
            master_cast[party[0]].battle_ref = ref;
        case 2:
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos2,   x,pos2, 0, bs_ally_sprite_ref[0] );
            master_cast[party[0]].battle_ref = ref;
            
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos4,   x,pos4, 0, bs_ally_sprite_ref[1] );
            master_cast[party[1]].battle_ref = ref;
        case 3:
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos3,   x,pos3, 0, bs_ally_sprite_ref[0] );
            master_cast[party[0]].battle_ref = ref;
            
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos1,   x,pos1, 0, bs_ally_sprite_ref[1] );
            master_cast[party[1]].battle_ref = ref;
            
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos5,   x,pos5, 0, bs_ally_sprite_ref[2] );
            master_cast[party[2]].battle_ref = ref;
        case 4:
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos2,   x,pos2, 0, bs_ally_sprite_ref[0] );
            master_cast[party[0]].battle_ref = ref;
            
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos4,   x,pos4, 0, bs_ally_sprite_ref[1] );
            master_cast[party[1]].battle_ref = ref;
            
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos1,   x,pos1, 0, bs_ally_sprite_ref[2] );
            master_cast[party[2]].battle_ref = ref;
            
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos3,   x,pos3, 0, bs_ally_sprite_ref[3] );
            master_cast[party[3]].battle_ref = ref;
        case 5:
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos3,   x,pos3, 0, bs_ally_sprite_ref[0] );
            master_cast[party[0]].battle_ref = ref;
            
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos2,   x,pos2, 0, bs_ally_sprite_ref[1] );
            master_cast[party[1]].battle_ref = ref;
            
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos4,   x,pos4, 0, bs_ally_sprite_ref[2] );
            master_cast[party[2]].battle_ref = ref;
            
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos1,   x,pos1, 0, bs_ally_sprite_ref[3] );
            master_cast[party[3]].battle_ref = ref;
            
            x = base_x + Random( min_x, max_x );
            ref = mcg_add_sprite( x,pos5,   x,pos5, 0, bs_ally_sprite_ref[4] );
            master_cast[party[4]].battle_ref = ref;
        default:
            ErrorHandler(
                "Error in battle.vc::BsPlacePartySprites(), illegal party size("+str(PartySize())+"):"+
                "The sully simpletype system can only handle partys of size 1-5 "+
                "by default.  If you want more, you must modify the system."
            );
    }

}


int RenderBattle()
{
    mcg_process_sprites();  //autocycle any sprites on the heap.
    mcgrender();        //render the heap.
}

int ActiveBattleAllyIdx;

void DrawBattleHUD()
{
    int x, y, i;
    x = 132;
    y = 1;
    
    MenuDrawBackground( x,y, 318,69, 1 );
    
    x += 8;
    y += 7;
    
    for( i=0; i<PartySize(); i++ )
    {
        if( master_cast[party[i]].cur_hp > 0 ) // YOU KNOW, WE DO HAVE ACCESSORS FOR THIS KIND OF THING
                                               //       I'M JUST SAYING
        {
            PrintString( x,y, screen, fontBattleWhite, master_cast[party[i]].name );
            PrintRight( x+101,y, screen, fontBattleWhite, str(master_cast[party[i]].cur_hp) );
        }
        else
        {
            PrintString( x,y, screen, fontBattleGrey, master_cast[party[i]].name );
            PrintRight( x+101,y, screen, fontBattleRed, "0" );
        }
        
        DrawBattleMeters( x+102, y, party[i] );
        
        PrintRight( x+169,y, screen, fontBattleWhite, str(master_cast[party[i]].cur_mp) );
        
        y += FontHeight(fontBattleWhite) + 1;
    }
    
}

void DrawBattleMeters( int x, int y, int cast_idx )
{   
    // border
    Line( x,y+1, x,y+3, RGB(0,0,0), screen);
    Line( x,y+5, x,y+7, RGB(0,0,0), screen);
    Line( x+36,y+1, x+36,y+3, RGB(0,0,0), screen);
    Line( x+36,y+5, x+36,y+7, RGB(0,0,0), screen);
    
    Line( x+1,y, x+35,y, RGB(0,0,0), screen);
    Line( x+1,y+4, x+35,y+4, RGB(0,0,0), screen);
    Line( x+1,y+8, x+35,y+8, RGB(0,0,0), screen);
    
    
    // hp
    Line( x+1,y+1, x+35,y+1, RGB(255,0,0), screen);
    Line( x+1,y+2, x+35,y+2, RGB(255,42,42), screen);
    Line( x+1,y+3, x+35,y+3, RGB(255,0,0), screen);
    
    // mp
    Line( x+1,y+5, x+35,y+5, RGB(0,0,255), screen);
    Line( x+1,y+6, x+35,y+6, RGB(42,42,255), screen);
    Line( x+1,y+7, x+35,y+7, RGB(0,0,255), screen);
}

/// -1 if the allys are ambushed, 1 if the enemies are ambushed, 0 if nobody is ambushed.
int battleIsAmbush()
{   
    return 0;
}

void BsSeedBattleQueue()
{
    int i;

    // enemies are ambushed,
    if( battleIsAmbush() == 1 )
    {
        for( i=0; i<PartySize(); i++ )
        {
            add_battle_queue_entry( Random(1,50), party[i], PARTY_ALLY, BACT_DELAY, "" );
        }
        
        for( i=0; i<battle_enemy_count; i++ )
        {
            add_battle_queue_entry( Random(51,100), i, PARTY_ENEMY, BACT_DELAY, "" );
        }
    }
    
    // allies are ambushed,
    else if( battleIsAmbush() == -1 )
    {
        for( i=0; i<PartySize(); i++ )
        {
            add_battle_queue_entry( Random(51,100), PARTY_ALLY, party[i], BACT_DELAY, "" );
        }
        
        for( i=0; i<battle_enemy_count; i++ )
        {
            add_battle_queue_entry( Random(1,50), i, PARTY_ENEMY, BACT_DELAY, "" );
        }   
    }
    
    // nobody is ambushed,
    else
    {
        for( i=0; i<PartySize(); i++ )
        {
            add_battle_queue_entry( Random(1,50), party[i], PARTY_ALLY, BACT_DELAY, "" );
        }
        
        for( i=0; i<battle_enemy_count; i++ )
        {
            add_battle_queue_entry( Random(1,50), i, PARTY_ENEMY, BACT_DELAY, "" );
        }       
    }
}


/*
int __TEST_stamp;
int __TEST_myfont = LoadFont("fred.png");
int __TEST_initd;

void __TEST_bouncy()
{       
    int randx, randy;
    int i;

    
    if( !__TEST_initd )
    {
        InitBouncy();   //yo, make a like a ball, and bounce!
        
        __TEST_stamp = timer;
        __TEST_myfont = LoadFont("fred.png");
        EnableVariableWidth(__TEST_myfont);

        __TEST_initd = 1;
    }

    if( timer-__TEST_stamp > 125 ) 
    {
        randx = Random(0,320-32);
        randy = Random(30,200-8);

        i = Random( 1,10 );

        if( i == 1 )
        {
            CreateBouncyString( "miss!", randx, randy, __TEST_myfont, 650, 800, Random(0,1) );
        }
        else if( i == 2 )
        {
            CreateBouncyString( "<overkill>", randx, randy, __TEST_myfont, 650, 800, Random(0,1) );
        }
        else
        {   
            CreateBouncyString( str(Random(1,9999)), randx, randy,__TEST_myfont, 650, 800, Random(0,1) );
        }

        __TEST_stamp = timer;   
    }

    DoBouncy(); //this should be hooked to retrace, but that would require a map
}
*/

/// returns the master_cast idx of a random party member.  chooses from only the living if living_only is true.
/// errors if nobody was living.
int SelectRandomAlly( int living_only )
{
    int i, j;
    
    if( !allyPartyLives() && living_only )
    {
        ErrorHandler( "SelectRandomAlly(): Wanted to select a random living ally, but none were alive." );
    }
    
    j = 0;
    for( i=0; i<PartySize(); i++ )
    {
        if( living_only )
        {
            if( !AllyIsIncapacitated(party[i]) )
            {
                arTemp[j] = party[i];
                j++;            
            }
        }
        else
        {
            arTemp[j] = party[i];
            j++;
        }
    }
    
    return arTemp[Random(0,j-1)];
}

/// returns the master_cast idx of a random party member.  chooses from only the living if living_only is true.
/// errors if nobody was living.
int SelectRandomEnemy( int living_only )
{
    int i, j;
    
    if( !enemyPartyLives() && living_only )
    {
        ErrorHandler( "SelectRandomEnemy(): Wanted to select a random living enemy, but none were alive." );
    }
    
    j = 0;
    for( i=0; i<enemyPartySize(); i++ )
    {
        if( living_only )
        {
            if( !EnemyIsIncapacitated(i) )
            {
                arTemp[j] = i;
                j++;            
            }
        }
        else
        {
            arTemp[j] = i;
            j++;
        }
    }
    
    return arTemp[Random(0,j-1)];
}


int getStandardDelay()
{
    return BASE_DELAY;
}

int getBaseToHit()
{
    return BASE_HIT;
}


/// The callfunction for the most standard of RPG battle actions: the attack.
///
/// This function expects one, and only one, Target to have it's Text == "Attacker" (case-insens)
/// This function expects one or more Targets
/// The minimum number of entries in the targetting table for this function is 2.
///
/// Actions this function takes:
///
/// * Calculates the tohit for the attacker to hit each target.
///     * if hit, calculates the base damage for the attack
///     * then calculates the valid elemental modifiers from the attack's element to the defenders resistances.
/// * then checks for critical hit.
/// * Sets the attacker's animation to 'ATTACK'.
/// * If they were hit, sets the defenders animation to 'HIT'.
/// * If they avoided the attack, sets the defender's animation to 'EVADE', if valid.
/// * Blits the proper default 'slash' animation for the attacker over the hit defenders.
/// * Once that finishes, adds bouncy digits centered to the bottom of the targets in the proper amounts.
/// * If the defender evaded, adds a bouncy 'Miss!' or somesuch in place of the damage.
/// * The function then applies the appropriate damage to the cur_hp of the appropriate attackers.
/// * Checks for death.
/// * any surviving hit defenders make a check for counterattack.
///
/// NOTE: currently uses the arTemp array to store the results of the to-hit and damage calcs (-1 is a miss, >=0 is a hit)
void BasicAttackFunc()
{
    int i;
    int attacker_idx = -1;
    int attacker_party;
    
    int apply_damage;
    
    if( GetTargettingCount() < 2 )
    {
        ErrorHandler( "BasicAttackFunc(): there were too few targets in the targetting array, needed at least an attacker and a defender" );
        return;
    }
    
    for( i=0; i<GetTargettingCount(); i++ )
    {
        if( equ(GetTargText(i), "Attacker") )
        {
            if( attacker_idx < 0 )
            {
                attacker_idx = GetTargID(i);
                attacker_party = GetTargMode(i);
Log( "BasicAttackFunc" );               
                ChangeSpriteAnimation( bat_getRenderRef(GetTargID(i), GetTargMode(i)), "ATTACK" );
            }
            else
            {
                ErrorHandler( "BasicAttackFunc(): there were too many attackers in the targetting array, needed one and only one." );
                return;         
            }
        
        }
    }
    
    /// this battle effect retargets if the former target was dead (and there was only one victim)
    AttemptSingleLivingRetarget();
    
    int change_type;
    
    for( i=0; i<GetTargettingCount(); i++ )
    {
        apply_damage = 0;
        change_type = 0;
    
        if( equ(GetTargText(i), "Target") )
        {
            BasicTohit( 
                attacker_idx, 
                attacker_party, 
                GetTargID(i), 
                GetTargMode(i), 
                1 
            );
            
            arTemp[i] = GetToHitResult();
            
            if( arTemp[i] == ATTACK_MISS )
            {
Log( "CALLING BasicDamageCalc( MISS )..." );
                change_type = BS_CHANGE_MISS;
            }
            else
            {
            
//SetSpriteHit( bat_getRenderRef(GetTargID(i), GetTargMode(i)) );
//ChangeSpriteAnimation( bat_getRenderRef(GetTargID(i), GetTargMode(i)), "HIT" );
            
                if( arTemp[i] == ATTACK_HIT ) //
                {
//Log( "CALLING BasicDamageCalc( normal )..." );

//BasicDamageCalc( int att_idx, int att_party, string attack_elem_csv, int skill_power, int def_idx, int def_party, int is_mag, int is_tech, int is_crit )
                    
                    arTemp[i+GetTargettingCount()] = BasicDamageCalc( 
                        attacker_idx, 
                        attacker_party, 
                        bat_attackElementList(attacker_idx,attacker_party),
                        0,
                        GetTargID(i), 
                        GetTargMode(i), 
                        0,
                        0,
                        0
                    );
                                    
                    change_type = BS_CHANGE_HP;
                    
                    apply_damage = 1;
                    
                }
                else if( arTemp[i] == ATTACK_CRIT )
                {
//Log( "CALLING BasicDamageCalc( crit )..." );
                    arTemp[i+GetTargettingCount()] = BasicDamageCalc( 
                        attacker_idx, 
                        attacker_party, 
                        bat_attackElementList(attacker_idx,attacker_party),
                        0,
                        GetTargID(i), 
                        GetTargMode(i), 
                        0,
                        0,
                        1
                    );
                    
                    apply_damage = 1;
                    change_type = BS_CHANGE_CRIT_HP;
                }
            }
        }
        
        /// ignore PARTY_NULL directives.
        else if( GetTargMode(i) == PARTY_NULL )
        {
        
        }
        
        /// else, set the attacker to attack-animation!
        else
        {
LOG( "ChangeSpriteAnimation ///else, set the attacker to attack-animation!" );
            ChangeSpriteAnimation( bat_getRenderRef(GetTargID(i), GetTargMode(i)), "ATTACK" );
        }
    
        /// temporary measure
        if( apply_damage || change_type )
        {
            AddGATTACA( 
                GetTargID(i), 
                GetTargMode(i) 
                change_type, 
                arTemp[i+GetTargettingCount()], 
            );
            
            
            // This is temporary and just sets a hardcoded slashy in.
            
            if( change_type != BS_CHANGE_MISS )
            {
                SetGATTACASlashy( GetTargID(i), GetTargMode(i), 1 );
                
                //remember to eventualy check for stone/death/other-non-hitty conditions.
                SetGATTACAAnimStrand( GetTargID(i), GetTargMode(i), "HIT" );
            }
        }
    }
    
    /// Basic Attack Func doesn't have any non-GATTACA animations or anything, 
    /// so let's just trigger GATTACA now!
    
    /// turn the primary battle effect off and trigger GATTACA
    TurnBattleEffectOff( 1 );
//AreBattleEffectsRendering();
//Exit("LAWL");
}


/// This is used for the normal attack and any non-percentile attack skill.
/// 
/// STEP ONE: 
/// If the attack is a normal attack or a technical skill, divide the attacker's Attack Value by
/// the defender's Defense Value to get the base damage. If it's a magical skill, divide 
/// (attacker's MAG * skill's Power) by the defender's MGR to get the base damage.
/// 
/// <s>STEP TWO: ----- OLD DATA ----
/// If the attack is a technical skill, multiply the base damage by (skill's Power / 100). Magical 
/// skills use their Power as an analogue to the ATK stat, so they don't do this.</s>
/// 
/// STEP THREE: Apply the target's affinity with the element of the attack. 
/// 
/// STEP FOUR: Apply the highest Guard currently protecting the target. Multiple simulteneous guards
/// don't stack. Recall that the Guard is a percent value out of 100 -- you multiply the damage
/// by [(100 - Guard)/100] .
/// 
/// STEP FIVE: If the target has the status effects Protect, Barrier, Fragile, Depress, or
/// Invincible (or anything else that alters damage directly), apply the effects as appropriate.
/// 
/// STEP SIX: If the damage is greater than MAX_DAMAGE (or heals more than that, in the case of
/// elemental absorption), reduce it to MAX_DAMAGE. If the damage is 0, it must be raised back to
/// 1 *unless* a perfect defense was applied to it. A perfect defense is either a Guard of 100+,
/// a condition like Invincible that totally stops damage, or a Null-element effect.
/// 
/// (Steps three, four and five can actually be done in any order, since they just involve 
/// multipliers.)
/// 
/// @param att_idx the attacker's battle actor index.
/// @param att_party the attacker's battle party index.
/// @param attack_elem_csv a comma-delimited string of all the elements this attack is charged with.
/// @param skill_power the 'power modifier' for the skill being calc'd here.  whee.  pass in a zero or negative power to ignore power-based calculations.
/// @param def_idx the defender's battle actor index.
/// @param def_party the defender's battle party index.
/// @param is_mag 1 if it's a magic-based attack, 0 if it's a physical attack.
/// @param is_tech 1 if it's a technical skill, 0 if not.  If is_mag is true, then anything this effects is ignored.
/// @param is_crit 1 if it's a critical hit, 0 if not.
int BasicDamageCalc( int att_idx, int att_party, string attack_elem_csv, int skill_power, int def_idx, int def_party, int is_mag, int is_tech, int is_crit )
{
    int base_damage;
    int perfect_defense;
    int guard;

string pMode;
if( !is_mag ) pMode = "physical"; else pMode = "magical(pow="+str(skill_power)+")";
if( is_tech ) pMode += ",tech(pow="+str(skill_power)+")";
bLog( "* BasicDamageCalc setup ("+pMode+"): " );
if( !is_mag ) {
bLog( "  - ATTACKER: '"+bat_getName(att_idx,att_party)+"' ("+bat_partyname(att_party)+") with AtV("+str(bat_AtV( att_idx, att_party )) +")" );
bLog( "  - DEFENDER: '"+bat_getName(def_idx,def_party)+"' ("+bat_partyname(def_party)+") with DfV("+str(bat_DfV( def_idx, def_party )) +")" );
} else {
bLog( "  - ATTACKER: '"+bat_getName(att_idx,att_party)+"' ("+bat_partyname(att_party)+") with AtV("+str(bat_AtV( att_idx, att_party )) +")" );
bLog( "  - DEFENDER: '"+bat_getName(def_idx,def_party)+"' ("+bat_partyname(def_party)+") with DfV("+str(bat_DfV( def_idx, def_party )) +")" );
}

    ///Step 1
    
    
    if( !is_mag )
    {
        base_damage = _get_physical_base_damage( att_idx, att_party, def_idx, def_party );
    }
    else
    {
        base_damage = _get_magical_base_damage( att_idx, att_party, def_idx, def_party, skill_power );
    }
        
    //Step 2, Tech!
    if( is_tech && !is_mag && skill_power > 0 )
    {
bLog( "* BasicDamageCalc step 2 (before): base damage = " + str(base_damage) );
        base_damage = (base_damage*skill_power)/100;
bLog( "* BasicDamageCalc step 2 (after): base damage = " + str(base_damage) );
    }
    else
    {
bLog( "* BasicDamageCalc step 2: Not a tech.  Moving on." );
    }

    //Step 3
    base_damage = calc_elem_modifier( 
        bat_attackElementList(att_idx, att_party), 
        def_idx, 
        def_party, 
        base_damage 
    );
    
bLog( "* BasicDamageCalc step 3 (after elem): base damage = " + str(base_damage) ); 
    
    //step 4
    guard = get_best_guard( def_idx, def_party );

bLog( "* BasicDamageCalc step 4a: best guard = " + str(guard) );    
    
    if( guard >= 100 )
    {
bLog( "perfect defense.  damage averted." );

///this flag is kinda dumb right now.
///@todo ask gayo about the perfect_defense jazz again
perfect_defense = 1;
        return 0;
    }
    else if( guard >= 1 )
    {
        base_damage = base_damage * (100-guard);
        base_damage = base_damage / 100;
    }
    
bLog( "* BasicDamageCalc step 4b: base_damage = " + str(base_damage) ); 
    
    //step 5
    
    /// check for the physical-attack-effecting 
    ///
    if( !is_mag )
    {
bLog( "* BasicDamageCalc step 5: physical-based damage status checks" );
        
        /// Protect reduces all the damage the character takes from physical sources 
        /// (attacks and technical skills) by 33%.
        if( bat_hasStatus( def_idx, def_party, "Protect" ) )
        {
            base_damage = base_damage * 2;
            base_damage = base_damage / 3;
        }

bLog( "* BasicDamageCalc step 5a (Protect?): base_damage = " + str(base_damage) );

        ///Fragile increases the damage the character takes from physical sources 
        ///(attacks and technical skills) by 50%.
        if( bat_hasStatus( def_idx, def_party, "Fragile" ) )
        {
            base_damage = base_damage * 3;
            base_damage = base_damage / 2;
        }

bLog( "* BasicDamageCalc step 5b (Fragile?): base_damage = " + str(base_damage) );
    }
    
    /// check for the magical-attack-effecting 
    ///
    else 
    {
bLog( "* BasicDamageCalc step 5: magical-based damage status checks" );
    
        /// Barrier reduces all the damage the character takes from magical sources 
        /// (magical skills) by 33%.
        if( bat_hasStatus( def_idx, def_party, "Barrier" ) )
        {
            base_damage = base_damage * 2;
            base_damage = base_damage / 3;

bLog( "* BasicDamageCalc step 5a (Barrier?): base_damage = " + str(base_damage) );
        }
        
        ///Depress increases the damage the character takes from magical sources 
        ///(magical skills) by 50%.
        if( bat_hasStatus( def_idx, def_party, "Depress" ) )
        {
            base_damage = base_damage * 3;
            base_damage = base_damage / 2;

bLog( "* BasicDamageCalc step 5b (Depress?): base_damage = " + str(base_damage) );  
        }

    }
    
    ///Invincible makes all damage 0.  Haha.    
    if( bat_hasStatus( def_idx, def_party, "Invincible" ) )
    {

bLog( "* BasicDamageCalc step 5c (Invincible?): base_damage = " + str(base_damage) +"...BUT THEN TURNED TO 0! " );
        return 0;
    }
    
    
    /// Barrier reduces all the damage the character takes from magical sources 
    /// (attacks and technical skills) by 33%.
    
    ///Depress increases the damage the character takes from magical sources by 50%..
    
    
    /// Step increase damage by 50% if it was critical
    if( is_crit )
    {
        base_damage = base_damage * 3;
        base_damage = base_damage / 2;  
bLog( "* BasicDamageCalc step 5d (Critical?): base_damage = " + str(base_damage) );
    }
         
    
    /// Step 6
    if( base_damage < 0 && base_damage < -MAX_DAMAGE )
    {
bLog( "* BasicDamageCalc step 6a (MAX HEAL): damage = " + str(-MAX_DAMAGE) );
        return -MAX_DAMAGE;
    }
    else if( base_damage == 0 )
    {
        if( perfect_defense )
        {
bLog( "* BasicDamageCalc step 6b (perfect defense): damage = 0" );
            return 0;
        }
        else
        {
bLog( "* BasicDamageCalc step 6c (MIN DAMAGE): damage = 1" );
            return 1;
        }
    }
    else if( base_damage > MAX_DAMAGE )
    {
    
bLog( "* BasicDamageCalc step 6d (MAX DAMAGE): damage = " +str(MAX_DAMAGE) );
        return MAX_DAMAGE;
    }
    
bLog( "* BasicDamageCalc step 6e (damage): damage = " + str(base_damage) );
    return -base_damage;
}

int _get_physical_base_damage( int att_idx, int att_party, int def_idx, int def_party )
{
    return bat_AtV( att_idx, att_party ) / bat_DfV( def_idx, def_party );
}

int _get_magical_base_damage( int att_idx, int att_party, int def_idx, int def_party, int skill_power )
{

if( skill_power <= 0 )
{
bLog( " _get_physical_base_damage() had a skill_power passed in of <= 0 ("+str(skill_power)+
").  That really shouldn't happen in this system. " );
}

    return (bat_mag( att_idx, att_party )*skill_power) / bat_mgr( def_idx, def_party );
}


int ___attack_hit;
int GetToHitResult()
{   
    return ___attack_hit;
}

/**
 * The Hit Formula is used for any direct offensive ability that has a chance of failure. 
 * 
 * This is almost identical to Hahn's formula, because I like it. This makes reference to a 
 * BASE_HIT value -- that value is normally 80, but it might need tweaking during playtesting.
 * 
 * STEP ONE: 
 * If the attack is a normal attack or a physical attack skill, divide the attacker's HIT by the
 * defender's DOD. If it's a magical attack skill that for some reason has a chance to miss, 
 * divide the attacker's MAG by the defender's MGR. Preserve this ratio to at least a couple of
 * decimal places. 
 * 
 * STEP TWO:
 * If the ratio is 1 or less, multiply BASE_HIT by the ratio to get the modified hit. If the ratio
 * is greater than 1, you do the complicated thing Hahn describes. Specifically, you multiply
 * (100 - BASE_HIT) by (ratio - 1) and add this value to the modified hit. So if the ratio were
 * 1.2 and BASE_HIT = 80, this would set the modified hit to 84.
 * 
 * STEP THREE: 
 * If the target of the attack is disabled through a disabling condition like Sleep or Paralysis,
 * increase the modified hit by (100 - BASE_HIT). This is a flat increase, not a multiplier.
 * 
 * STEP FOUR: ***********IGNORED FOR NOW***********
 * If a skill is being used, multiply the modified hit by (Skill's Accuracy / 100) to 
 * get the final value of the modified hit rate.
 * 
 * STEP FIVE: 
 * The critical hit chance is equal to (modified hit * attacker's FER / 100). Some 
 * kinds of skills (spells, mostly) might not have a chance to critical, while others might always
 * critical.
 * 
 * STEP SIX: Roll a d100. A natural 1 is always a hit and a natural 100 is always a miss. Otherwise,
 * the attack is a hit if the value rolled is equal to or less than the modified hit, and the attack
 * is a critical if the value rolled is equal to or less than the critical hit chance.
 *
 * if a skill isn't being used, pass a negative value into skill_idx.
 */
void BasicTohit( int attacker_idx, int attacker_party, int defender_idx, int defender_party, int is_physical )
{
    int att_hit, def_dod;
    int att_mag, def_mgr;
    int att_fer;
    
    int ratio;
    int mod_hit = BASE_HIT;
    int mod_crit;
    
    int roll;
    
    /// Step 1
    if( is_physical )
    {
        att_hit = bat_hit( attacker_idx, attacker_party );
        def_dod = bat_dod( defender_idx, defender_party );
//log( "att_hit: " + str(att_hit) );
//log( "def_dod: " + str(def_dod) );
        ratio = (att_hit*100)/def_dod;
//log( "ratio: " + str(ratio) );
    }
    else
    {
        att_mag = bat_mag( attacker_idx, attacker_party );
        def_mgr = bat_mgr( defender_idx, defender_party );
//log( "att_mag: " + str(att_mag) );
//log( "def_mgr: " + str(def_mgr) );        
        ratio = (att_mag*100)/def_mgr;  
//log( "ratio: " + str(ratio) );
    }
    
    att_fer = bat_fer( attacker_idx, attacker_party );
//log( "att_fer: " + str(att_fer) );    
    /// Step 2.  ratio is actually *100 now, so when we check for <=1, we're actually checking
    ///          <=100.  Stupid fixed point.
    if( ratio <= 100 )
    {
        mod_hit = (BASE_HIT * ratio)/100;
    }
    else
    {
        ratio -= 100;
        mod_hit += (((100 - BASE_HIT) * ratio)/100);
    }

    /// Step 3  
    if( 
        bat_hasStatus(defender_idx,defender_party, "SLEEP") ||
        bat_hasStatus(defender_idx,defender_party, "PARALYSIS")
    )
    {
        mod_hit += (100 - BASE_HIT);    
    }
    
    
    /// Step 4
    /*
    if( skill_idx >= 0 )
    {
    
    }
    */
    
    /// Step 5
    /// modified hit * attacker's FER / 100
    mod_crit = mod_hit / att_fer;
//log( "mod hit: " + str(mod_hit) );    
//log( "mod crit: " + str(mod_crit) );  

    /// Step 6

/* STEP SIX: Roll a d100. A natural 1 is always a hit and a natural 100 is always a miss. Otherwise,
* the attack is a hit if the value rolled is equal to or less than the modified hit, and the attack
* is a critical if the value rolled is equal to or less than the critical hit chance.
*/

    roll = Random(1,100);
    
    if( roll == 1 )
    {
        ___attack_hit = ATTACK_HIT;
    }
    else if( roll == 100 )
    {
        ___attack_hit = ATTACK_MISS;
    }
    else
    {
        if( roll <= mod_crit )
        {
            ___attack_hit = ATTACK_CRIT;
        }
        else if( roll <= mod_hit )
        {
            ___attack_hit = ATTACK_HIT;
        }
        else
        {
            ___attack_hit = ATTACK_MISS;
        }
    }
        
//log( "roll: " + str(roll) );
//log( "result: " + str(___attack_hit) );
//log( "" );
}

/// takes a csv of elements to check for affinity and returns the damage that should be applied to 
/// a given target.
int calc_elem_modifier( string att_elem_csv, int def_idx, int def_party, int base_damage )
{
    int att_cnt = TokenCount(att_elem_csv,",");
    int i, tmp;
    
    if( att_cnt < 1 )   return base_damage;
    
    switch( ELEMENTAL_OVERLAP_POLICY )
    {
        case ELEMENTAL_POLICY_BEST:
            tmp = calc_elem_mod_best( att_elem_csv, def_idx, def_party, base_damage );
        case ELEMENTAL_POLICY_WORST:
            tmp = calc_elem_mod_worst( att_elem_csv, def_idx, def_party, base_damage );
        case ELEMENTAL_POLICY_STACK:
            tmp = calc_elem_mod_stack( att_elem_csv, def_idx, def_party, base_damage );
    }
    
    return tmp;
}

/// helper function.  The best elemental modifier (the one that provides the least damage or most HP gain) prevails.
///
/// basically, if there are any Absorbs that mathc for this atack, then the damage gets inverted.  Failing
/// that, any matching negates turn the damage to 0.  Failing that, any matching halves halve the damage.  Failing
/// that, any matching doubles double the damage.  Failing that, the damage is returned unmodified.
///
/// damage is positive values, healing is negative.
int calc_elem_mod_best( string att_elem_csv, int def_idx, int def_party, int base_damage )
{
    int i;
    
    int att_cnt = TokenCount(att_elem_csv,",");
    string element;
    
    ///check for absorb first.
    for( i=0; i<att_cnt; i++ )
    {
        element = GetToken( att_elem_csv,",",i );
        
        if( bat_hasElemAbsorb(def_idx, def_party, element) )
        {
            return -base_damage;
        }
    }
    
    ///check for null next.
    for( i=0; i<att_cnt; i++ )
    {
        element = GetToken( att_elem_csv,",",i );
        
        if( bat_hasElemNegate(def_idx, def_party, element) )
        {
            return 0;
        }
    }
    
    /// check for half next.
    for( i=0; i<att_cnt; i++ )
    {
        element = GetToken( att_elem_csv,",",i );

        if( bat_hasElemHalf(def_idx, def_party, element) )
        {
            return base_damage/2;
        }
    }
    
    /// check for double last.
    for( i=0; i<att_cnt; i++ )
    {
        element = GetToken( att_elem_csv,",",i );

        if( bat_hasElemDouble(def_idx, def_party, element) )
        {
            return base_damage*2;
        }
    }
    
    return base_damage;
}

/// helper function.  The worst elemental modifier (the one that provides the most damage or least HP gain) prevails.
///
/// this function returns the first most 'hurty' thing it can, in exactly the reverse order to calc_elem_mod_best().
///
/// damage is positive values, healing is negative.
int calc_elem_mod_worst( string att_elem_csv, int def_idx, int def_party, int base_damage )
{
    int i;
    
    int att_cnt = TokenCount(att_elem_csv,",");
    string element;
    
    /// check for double first.
    for( i=0; i<att_cnt; i++ )
    {
        element = GetToken( att_elem_csv,",",i );

        if( bat_hasElemDouble(def_idx, def_party, element) )
        {
            return base_damage*2;
        }
    }
    
    /// check for half next.
    for( i=0; i<att_cnt; i++ )
    {
        element = GetToken( att_elem_csv,",",i );

        if( bat_hasElemHalf(def_idx, def_party, element) )
        {
            return base_damage/2;
        }
    }
    
    ///check for null next.
    for( i=0; i<att_cnt; i++ )
    {
        element = GetToken( att_elem_csv,",",i );
        
        if( bat_hasElemNegate(def_idx, def_party, element) )
        {
            return 0;
        }
    }
    
    
    ///check for absorb last.
    for( i=0; i<att_cnt; i++ )
    {
        element = GetToken( att_elem_csv,",",i );
        
        if( bat_hasElemAbsorb(def_idx, def_party, element) )
        {
            return -base_damage;
        }
    }
    
    return base_damage;
}

/// helper function.  Calculates stacking modifiers.  a single absorb makes it all healing, a single negate makes it all nothing.
///
/// Example, if the defender has Half: Fire, Water; Double Lightning, and gets hit with a 50 base damage attack with Fire and Water
/// elements, the damage is quartered, not just halved, and becomes 12 (rounds down).  If the attack was Fire,Water,Lit, the damage would 
/// be 25, since the double cancels out one of the halves.  If it was just lightning-based, the damage would be 100.  If it was 
/// lightning and fire, they'd cancel each other out and 
///
/// damage is positive values, healing is negative.
int calc_elem_mod_stack( string att_elem_csv, int def_idx, int def_party, int base_damage )
{
    int healmode, negatemode, tmp;
    int i;
    
    int numerator = 1;
    int denominator = 1;
    
    int att_cnt = TokenCount(att_elem_csv,",");
    string element;
    
    for( i=0; i<att_cnt; i++ )
    {
        element = GetToken( att_elem_csv,",",i );

        if( bat_hasElemNegate(def_idx, def_party, element) )
        {
            return 0;
        }
        
        if( bat_hasElemAbsorb(def_idx, def_party, element) )
        {
            healmode = 1;
        }
        
        if( bat_hasElemHalf(def_idx, def_party, element) )
        {
            denominator = denominator * 2;
        }
        
        if( bat_hasElemDouble(def_idx, def_party, element) )
        {
            numerator = numerator * 2;
        }
    }
    
    /// if the ELEMENTAL_POLICY_STACK_MAX mode is defined, check for excessive values and
    /// truncate them
    if( ELEMENTAL_POLICY_STACK_MAX > 1 )
    {
        if( numerator > ELEMENTAL_POLICY_STACK_MAX )
            numerator = ELEMENTAL_POLICY_STACK_MAX;
        
        if( denominator > ELEMENTAL_POLICY_STACK_MAX )
            denominator = ELEMENTAL_POLICY_STACK_MAX;
    }
    
    tmp = base_damage * numerator;
    tmp = tmp / denominator;
    
    if( healmode )
    {
        tmp = tmp * -1;
    }
    
    return tmp;
}

int _bm_idx, _prev_bm_idx;

/// call this when starting up a battle menu for the first time for an action.
void TurnBattleMenuOn( int cast_idx )
{       
//Log( "TurnBattleMenuOn("+str(cast_idx)+")..." );

    if( _prev_bm_idx >= 0 )
    {
//Log( " cleaning previous BM index "+str(_prev_bm_idx)+")" );

        CleanBattleMenu( _prev_bm_idx );
    }
    else
    {
//Log( " no cleaning necessary." );
    }

    _bm_idx = cast_idx;
    menu_cast = _bm_idx;
    
    master_cast[menu_cast].battle_menu_idx = menu_cast;
    master_cast[menu_cast].battle_menu_dirty = 0;

    SetBattleMenu( menu_cast, BM_MakeCastMenu(menu_cast, 1) );
    SetBMCursor( menu_cast, _defaultCursorBM );

    //SetBattleMenuPos( menu_cast, mcg_getX(ref_BattleHUD) - ImageWidth(master_battle_menus[menu_cast].scratch_img[0]), 10 );
    SetBattleMenuPos( menu_cast, 10,10 );

    // Uhh... should we be parsing the battle menu every time???

//Log( "Parsing BM Base!" );
    BM_Parse_Base( menu_cast );
//Log( " no cleaning necessary." );

//Log( "Dumping the BM for " + master_cast[menu_cast].name );
//dump_bm( menu_cast ); //removing this causes great sorrow in the battle system


    Unpress(0);

//Log( "Starting BM..." );
    StartBattleMenu( menu_cast );
    
//Log( "...TurnBattleMenuOn() done." );
//Exit("");
}

/// call this when going into targetting mode for a 
void PauseBattleMenu()
{
    __bm_visible = 0;
}

/// call this when
void UnpauseBattleMenu()
{
    __bm_visible = 1;
}

/// call this once you're done with the battle menu for this turn instance.
void TurnBattleMenuOff()
{
    _prev_bm_idx = _bm_idx;
    _bm_idx = -1;
}

int BattleMenuIsOff()
{
    if( _bm_idx < 0 ) return 1;
    return 0;
}


void HandleBattleMenu()
{
//Log( "HandleBattleMenu" );

    if( _bm_idx >= 0 )
    {
//Log( "HandleBattleMenu 2" );
        /// Battle Menu control code.
        if( master_battle_menus[menu_cast].mode_list )
            UpdateBattleMenuListControls(menu_cast);
        else
            UpdateBattleMenuControls(menu_cast);

        ///Check if we're in help mode...
        CheckHelpMode( menu_cast );

        ///Draw Battle Menu
        DrawBattleMenu(menu_cast,screen);

        if( master_battle_menus[menu_cast].mode_list )
            DrawBattleMenuList(menu_cast,screen);

        ///Draw Battle Menu Help
        if( __menuHelpMode )
        {
            TBlit( 10,14, __menuHelpModeIMG, screen );
        }
    }
}

/// remember to check for items first!
///
String GetBattleMenuHelpText( String _key )
{
    int idx;
    
    idx = GetSkill( _key );
        
    if( idx < 0 ) // it's not a skill.
    {
        idx = GetSkillType( _key );

        if( idx < 0 ) // it's not a skill type.
        {
            return AuxiliaryHelpText( _key );
        }
        else // it's a skill type.
        {
            return master_skilltypes[idx].desc;
        }
    }
    else // it's a skill.
    {
        return master_skills[idx].desc;
    }   
}

int __bm_targmode_on;
int __bm_targmode_custsounds = 0;
string __bm_targmode_callfunc;

void SetActiveBattleMenuTargetting( string s ) 
{
// Log( ">>>>>>>>>>>>>>>> SetActiveBattleMenuTargetting!!!!!!!!!!!!!!!!!!!!" );
// MessageBox( "'"+s+"'" );
    __bm_targmode_on = 1;
    __bm_targmode_callfunc = s;
    
    if( !__bm_targmode_custsounds )
    {
        set_selectmap_movefuncs( "MenuHappyBeep", "MenuAngryBuzz" );
        set_selectmap_actionfuncs( "MenuHappyBeep", "MenuHappyBeep" );
    }
    
    SM_autocalculate();

    //dump_all_selectnodes();
    
    Unpress( 0 );
}

void BattleMenuTargettingOff()
{
//Log( ">>>>>>>>>>>>>>>> BattleMenuTargettingOff!" );

    __bm_targmode_on = 0;
    __bm_targmode_callfunc = "";
}

void HandleBattleMenuTargetting()
{
//Log( "HandleBattleMenuTargetting..." );
    if( __bm_targmode_on )
    {
//Log( "HandleBattleMenuTargetting calls '"+__bm_targmode_callfunc+"'!" );
        CallFunction(__bm_targmode_callfunc);
    }
//Log( "...HandleBattleMenuTargetting" );
}

void HandleBattleMenuActorIndicator()
{
    int ridx;

    if( !BattleMenuIsOff() )
    {
        ridx = master_cast[_bm_idx].battle_ref;
                
        TBlit(
            mcg_getX(ridx) + (mcg_width(ridx)/2) - (ImageWidth(imBattleActorPointer)/2),
            mcg_getY(ridx) - ImageHeight(imBattleActorPointer),
            imBattleActorPointer,
            screen
        );
    }
}

int __after_effect_cigarette_break;
/// set the physical time pause between executing actions in the battle system (in 1/100ths of a second)
/// does not accept negative values.
void SetBattleEffectPauseTime( int dly )
{
    if( dly >= 0 )
    {
        __after_effect_cigarette_break = dly;
    }
}

/// returns how many 1/100ths of a second to wait between battle effects.
int GetBattleEffectPauseTime()
{
    return __after_effect_cigarette_break;
}

int __after_effect_cigarette, __after_effect_targtime;

/// returns true if we're presently rendering some pretty battle effects, false if we're 
/// ready to do the next battle queue entry.
///
/// This should *only* be called by the Battle Loop Processor.
int AreBattleEffectsRendering() {
    
    /// is a custom battle effect going on?
    if( IsBattleEffectOn() )
    {
//**// Log( "Render?  IsBattleEffectOn 1" );
        return 1;
    }
    else
//**// Log( "Render?  IsBattleEffectOn 0" );
    
    /// Are slashies, bouncy numbers, or any other GATTACA thing going on?
    if( isGATTACArunning() )
    {
//**// Log( "Render?  isGATTACArunning 1" );
        return 1;
    }
    else
//**// Log( "Render?  isGATTACArunning 0" );

    // if we're done with everything else, wait a little while...   
    if( !__after_effect_cigarette ) 
    {   
//**// Log( "Render?  cigg 0" );
        return 0;
    }
    
    /// and check if that time has elapsed.  
    /// If so, we're all done with this battle effect and we can move to the next action
    /// in the battle.  If not, continue waiting.
    else
    {
//**// Log( "Render?  cigg 1..." );
        if( __after_effect_targtime <= systemtime )
        {
//**// Log( "Render?  done smoking..." );
            __after_effect_cigarette = 0;
            return 0;
        }
        else
        {
//**// Log( "Render?  still smoking..." );
            return 1;
        }
    }
}


/// Check for player deaths, party deaths.  Make necessary changes.
///
///
void EndOfBattleAction()
{
    int i;

    for( i=0; i<enemyPartySize(); i++ )
    {
        if( equ(GetCurrentSpriteStrand(battle_enemies[i].render_idx),"hit") )
        {
            SetSpriteUnpause( battle_enemies[i].render_idx );
        }
    
        if( enemyIsIncapacitated(i) )
        {
            if( !nme_getDeadFlag(i) )
            {
                if( !equ(GetCurrentSpriteStrand(battle_enemies[i].render_idx),"death") )
                {
                    ChangeSpriteAnimation( battle_enemies[i].render_idx, "death" );
                }

                nme_setDead( i );

                trigger_on_death( i, PARTY_ENEMY );
            }           
        }
    }
    
    for( i=0; i<PartySize(); i++ )
    {
        if( equ(GetCurrentSpriteStrand(master_cast[party[i]].battle_ref),"hit") )
        {
            SetSpriteUnpause( master_cast[party[i]].battle_ref );
        }
    
        if( allyIsIncapacitated(i) )
        {
            if( !wasDead(party[i]) )
            {
                if( !equ(GetCurrentSpriteStrand(master_cast[party[i]].battle_ref),"death") )
                {
                    ChangeSpriteAnimation( master_cast[party[i]].battle_ref, "death" );
                }
                
                changeDeadFlag( party[i], 1 );
                
                trigger_on_death( party[i], PARTY_ALLY );
            }
        }
    }
    
    if( !allyPartyLives() )
    {
        PlayBattleGameOver();
    }
    else if( !enemyPartyLives() )
    {
        PlayBattleVictory();
    }
}


/// Ono!  You lost the game!  
///
void PlayBattleGameOver()
{
    /// this prevents the battle queue from advancing, and isn't cleared 
    /// by anything else since GATTACA has already fired.
    TurnBattleEffectOn( "LoseBattleEffect" );

    V1_StartMusic( "res/music/DREAMS.IT" );
}

/// Dance and show XP gains and stuff.  Yaaay!
void PlayBattleVictory()
{
    int i;  

    /// this prevents the battle queue from advancing, and isn't cleared 
    /// by anything else since GATTACA has already fired.
    TurnBattleEffectOn( "BattleVictoryEffect" );
    
    V1_StartMusic( "res/music/SWIN.IT" );
    
    for( i=0; i<PartySize(); i++ )
    {
        if( !allyIsIncapacitated(i) )
        {   
            if( !equ(GetCurrentSpriteStrand(master_cast[party[i]].battle_ref),"dance") )
            {
                ChangeSpriteAnimation( master_cast[party[i]].battle_ref, "dance" );
            }
        }
    }
}


void LoseBattleEffect() {
    
}

int __initRewards = 0;
void BattleVictoryEffect() 
{   
    if (!__initRewards) { CalculatePhatBattleBooty(); }
    
    if (!BattleMessageExists()) { TurnOffTheBattle(); }   
}


void DrawBattleQueue()
{
    
}


int _oldlevel[MAX_PARTY_SIZE]; // each ally's level prior to combat exp.
                               // this should probably be designed to be of
                               // local scope to CalculatePhatBattleBooty
                               // using Lua, but for now it isn't. Lol?

void CalculatePhatBattleBooty() {
    int i, n;
    int reward;
    string output;
    // This assumes that all the enemies currently in the party were defeated legitimately.
    // If we want to allow for some enemies to stay in the party without giving loot this
    // will require a bit of additional code.
    
    // Calculate EXP
    reward = 0;
    for (i = 0; i < EnemyPartySize(); i++) { reward += nme_exp(i); }

    // If the EXP division policy is used, EXP policy is divided between all party
    // members (if DEAD_EXP_SHARE is nonzero) or between all living party members
    // (if DEAD_EXP_SHARE is 0). Note that this uses integer division, so it can 
    // reduce small EXP totals to 0.
    if (EXP_POLICY == EXP_POLICY_DIVIDE) {
        if (DEAD_EXP_SHARE != 0) { reward = reward / PartySize(); } // count all PCs
        else { // count only living PCs
            n = 0;
            for (i = 0; i < PartySize(); i++) {
                if (!bat_is_dead(i, PARTY_ALLY)) n++;
            }           
            if (n <= 0) { ErrorHandler("Error in CalculatePhatBattleBooty: Somehow the number of living PCs was less than or equal to 0, even though the party won."); }
            reward = reward / n;
        }
    }
    
    if (reward < 0) { 
        ErrorHandler("Error in CalculatePhatBattleBooty: A negative amount of XP (" + str(reward) + ") was awarded."); 
        reward = 0;
    }
    
    for (i = 0; i < PartySize(); i++) { 
        _oldlevel[i] = getLevel(party[i]); // save what level the person was originally 
        if (reward > 0) {
            if (bat_is_dead(i, PARTY_ALLY)) {
                if (EXP_POLICY == EXP_POLICY_TOTAL && DEAD_EXP_SHARE > 0) GiveXPI(party[i], reward*DEAD_EXP_SHARE/100); // reward = DEAD_EXP_SHARE% usual
                else if (EXP_POLICY == EXP_POLICY_DIVIDE && DEAD_EXP_SHARE != 0) GiveXPI(party[i], reward); // reward = full if DEAD_EXP_SHARE nonzero, 0 otherwise
            }
            else GiveXPI(party[i], reward);
        }       
    } 
    
    output = "Received " + str(reward) + " EXP and ";

    // Calculate moneys
    reward = 0;
    for (i = 0; i < EnemyPartySize(); i++) { reward += nme_money(i); }

    if (reward < 0) { 
        ErrorHandler("Error in CalculatePhatBattleBooty: A negative amount of money (" + str(reward) + ") was awarded."); 
        reward = 0;
    }
    
    money += reward; // there doesn't appear to be a function to set money without fanfare

    output = output + str(reward) + " " + moneyname + "."; 
    QueueBattleMessage(output, TRUE, FALSE, TRUE, BMSG_TYPICAL_DURATION);
    
    // Level up animation goes here

	// Declare any new skills gained on level-up. (Doesn't announce skill names, because I'm lazy.)
    for (i = 0; i < PartySize(); i++) { 
    	if (_oldLevel[i] < getLevel(party[i])) {    		
    		n =	_skillsLearned(party[i], _oldLevel[i], getLevel(party[i]));
    		if (n == 1) QueueBattleMessage( bat_getName(i,PARTY_ALLY) + " learned a new skill.", TRUE, FALSE, TRUE, BMSG_TYPICAL_DURATION);
    		else if (n > 1) QueueBattleMessage( bat_getName(i,PARTY_ALLY) + " learned " + str(n) + " new skills.", TRUE, FALSE, TRUE, BMSG_TYPICAL_DURATION);
    	}    	
    } 

	// Now for the item drops, In this loop, reward holds the index of the item being considered.
	// It's initialized to -1 and we go through until we find an enemy that dropped something, then
	// sum up all the drops of that particular item, award them, and go back to the beginning.
	// If the whole loop completes with reward at -1 we surmise there is nothing left to assign.
	// Enemies we have already accounted for have their steal flag set to -1 to mark them as done.
	reward = 0;
	while (reward >= 0) {
		reward = -1; // initialize to no item
		for (i = 0; i < EnemyPartySize(); i++) {
			if (battle_enemies[i].stole_flag != -1) { // unprocessed enemy
				if (reward == -1) { // Not considering any item yet -- maybe this will be the first?					
					if (nme_dropCheck(i)) { // dropCheck only returns TRUE if the enemy has an item and actually rolls to drop it.
						reward = nme_DropItemIdx(i);  
						n = 1; // first one counted						
					}					
					battle_enemies[i].stole_flag = -1; // don't look at this enemy again
				}
				else if (reward == nme_DropItemIdx(i)) { // This enemy drops the item we're looking for right now
					if (nme_dropCheck(i)) n++; 					
					battle_enemies[i].stole_flag = -1; // don't look at this enemy again
				}
			}
		}
		
		if (reward >= 0) {
			GiveItemI(reward, n);
			QueueBattleMessage( "Procured " + GetItemNameI(reward) + " x" + str(n), TRUE, FALSE, TRUE, BMSG_TYPICAL_DURATION);
		}
	}


    __initRewards = 1;  
}



void setStartingBattleSpriteAnimations( int party_idx, int sprite_idx )
{
    if( isDead(party_idx) ) {
        ChangeSpriteAnimation( sprite_idx, "DEATH" );
    } else if( isWeak(party_idx) ) {
        ChangeSpriteAnimation( sprite_idx, "WEAK" );
    } else {
        ChangeSpriteAnimation( sprite_idx, "IDLE" );
    }
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////

void render_battle_debug_window()
{
    int debug_screen, y;

    if( !mode_battle_debug )
    {
        return;
    }
    
    debug_screen = WindowGetImage( h_window_debug );
    RectFill( 0,0, ImageWidth(debug_screen),ImageHeight(debug_screen), RGB(0,0,80), debug_screen );
    
    y = DrawBattleQueueText( debug_screen );
        
    PrintString( 10,y,debug_screen,fontBattleWhite, "ticks: " + str(_debug_tick_counter) );
    y += FontHeight(fontBattleWhite) + 1;
    
    if( debug_metamode_active )
    {
        PrintString( 10,y,debug_screen,fontBattleWhite, "active mode (press F8 to go to step-mode)" );
        y += FontHeight(fontBattleWhite) + 1;
    }
    else
    {
        PrintString( 10,y,debug_screen,fontBattleWhite, "step mode (press F8 to advance a tick, F5 to go to active mode)" );
        y += FontHeight(fontBattleWhite) + 1;   
    }
    
}


int DrawBattleQueueText( int my_screen )
{
    int i, y;
    
    string aod;
    
    for( i=0; i<(battle_queue_count+1); i++ )
    {   
        if( BattleQueueActorIsActive(i) )
            aod = "live ";
        else
            aod = "dead ";
    
        if( battle_queue[i].batent_party == PARTY_ALLY )
            PrintString( 1,y, my_screen, fontBattleWhite, aod+str(battle_queue[i].time)+","+master_cast[battle_queue[i].batent_ref].name+","+str(battle_queue[i].action)+","+battle_queue[i].data );
        else
            PrintString( 1,y, my_screen, fontBattleWhite, aod+str(battle_queue[i].time)+","+master_enemy[battle_enemies[battle_queue[i].batent_ref].master_enemy_idx].name+","+str(battle_queue[i].action)+","+battle_queue[i].data );
        
        y += FontHeight(fontBattleWhite) + 1;
    }
    
    y += FontHeight(fontBattleWhite) + 1;
    
    return y;
}

